{"version":3,"file":"js/210.babylonBundle.js","mappings":"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","sources":["webpack://webxrdemo/./src/support/xr.ts","webpack://webxrdemo/./src/scenes/main.ts","webpack://webxrdemo/./src/support/assetManager.ts","webpack://webxrdemo/./src/support/camera.ts","webpack://webxrdemo/./src/support/environment.ts"],"sourcesContent":["import {\n  Scene,\n  WebXRFeatureName,\n  PhysicsImpostor,\n  AbstractMesh,\n  WebXRState,\n  DefaultRenderingPipeline,\n  Vector3,\n  Ray,\n  Animation,\n  BezierCurveEase,\n} from \"@babylonjs/core\";\n\nexport const enableXR = async (\n  scene: Scene,\n  floorMeshes: AbstractMesh[],\n  pipeline?: DefaultRenderingPipeline\n) => {\n  // enable xr\n  const xr = await scene.createDefaultXRExperienceAsync();\n\n  // enable physics for xr\n  xr.baseExperience.featuresManager.enableFeature(\n    WebXRFeatureName.PHYSICS_CONTROLLERS,\n    \"latest\",\n    {\n      xrInput: xr.input,\n      physicsProperties: {\n        restitution: 0.5,\n        impostorSize: 0.1,\n        impostorType: PhysicsImpostor.BoxImpostor,\n      },\n      enableHeadsetImpostor: true,\n    }\n  );\n\n  // teleportation features\n  xr.baseExperience.featuresManager.enableFeature(\n    WebXRFeatureName.TELEPORTATION,\n    \"stable\",\n    {\n      xrInput: xr.input,\n      floorMeshes,\n      pickBlockerMeshes: [],\n    }\n  );\n\n  let observers: any = {};\n  let meshesUnderPointer: any = {};\n  const tmpVec = new Vector3();\n  const tmpRay = new Ray(new Vector3(), new Vector3());\n  let lastTimestamp = 0;\n  const oldPos = new Vector3();\n\n  xr.input.onControllerAddedObservable.add((inputSource) => {\n    inputSource.onMotionControllerInitObservable.add((motionController) => {\n      motionController.onModelLoadedObservable.add(async (_mc) => {\n        const mesh = inputSource.grip;\n        if (mesh && motionController.handedness === \"left\") {\n          const xr_ids = motionController.getComponentIds();\n          // get x button\n          const xbuttonComponent = motionController.getComponent(xr_ids[3]);\n          xbuttonComponent.onButtonStateChangedObservable.add(() => {\n            if (xbuttonComponent.pressed) {\n              console.log(\"X pressed!\");\n            }\n          });\n        }\n\n        const squeeze = motionController.getComponentOfType(\"squeeze\");\n        if (squeeze) {\n          squeeze.onButtonStateChangedObservable.add(() => {\n            if (squeeze.changes.pressed) {\n              if (squeeze.pressed) {\n                inputSource.getWorldPointerRayToRef(tmpRay, true);\n                tmpRay.direction.scaleInPlace(1.5);\n                const position = inputSource.grip\n                  ? inputSource.grip.position\n                  : inputSource.pointer.position;\n                let mesh = scene.meshUnderPointer;\n                if (xr.pointerSelection.getMeshUnderPointer) {\n                  mesh = xr.pointerSelection.getMeshUnderPointer(\n                    inputSource.uniqueId\n                  );\n                }\n                if (mesh && mesh.physicsImpostor) {\n                  Animation.CreateAndStartAnimation(\n                    \"meshmove\",\n                    mesh,\n                    \"position\",\n                    30,\n                    15,\n                    mesh.position.clone(),\n                    position.add(tmpRay.direction),\n                    Animation.ANIMATIONLOOPMODE_CONSTANT,\n                    new BezierCurveEase(0.3, -0.75, 0.7, 1.6),\n                    () => {\n                      if (!mesh) return;\n                      meshesUnderPointer[inputSource.uniqueId] = mesh;\n                      observers[inputSource.uniqueId] =\n                        xr.baseExperience.sessionManager.onXRFrameObservable.add(\n                          () => {\n                            const delta =\n                              xr.baseExperience.sessionManager\n                                .currentTimestamp - lastTimestamp;\n                            lastTimestamp =\n                              xr.baseExperience.sessionManager.currentTimestamp;\n                            inputSource.getWorldPointerRayToRef(tmpRay, true);\n                            tmpRay.direction.scaleInPlace(1.5);\n                            const position = inputSource.grip\n                              ? inputSource.grip.position\n                              : inputSource.pointer.position;\n                            tmpVec.copyFrom(position);\n                            tmpVec.addInPlace(tmpRay.direction);\n                            tmpVec.subtractToRef(oldPos, tmpVec);\n                            tmpVec.scaleInPlace(1000 / delta);\n                            meshesUnderPointer[\n                              inputSource.uniqueId\n                            ].position.copyFrom(position);\n                            meshesUnderPointer[\n                              inputSource.uniqueId\n                            ].position.addInPlace(tmpRay.direction);\n                            oldPos.copyFrom(\n                              meshesUnderPointer[inputSource.uniqueId].position\n                            );\n                            meshesUnderPointer[\n                              inputSource.uniqueId\n                            ].physicsImpostor.setLinearVelocity(Vector3.Zero());\n                            meshesUnderPointer[\n                              inputSource.uniqueId\n                            ].physicsImpostor.setAngularVelocity(\n                              Vector3.Zero()\n                            );\n                          }\n                        );\n                    }\n                  );\n                }\n              } else {\n                // throw the object\n                if (\n                  observers[inputSource.uniqueId] &&\n                  meshesUnderPointer[inputSource.uniqueId]\n                ) {\n                  xr.baseExperience.sessionManager.onXRFrameObservable.remove(\n                    observers[inputSource.uniqueId]\n                  );\n                  observers[inputSource.uniqueId] = null;\n                  meshesUnderPointer[\n                    inputSource.uniqueId\n                  ].physicsImpostor.setLinearVelocity(tmpVec);\n                }\n              }\n            }\n          });\n        }\n      });\n    });\n  });\n\n  xr.baseExperience.onStateChangedObservable.add((state) => {\n    switch (state) {\n      case WebXRState.IN_XR:\n        // XR is initialized and already submitted one frame\n        if (pipeline) {\n          pipeline.cameras.push(xr.baseExperience.camera);\n        }\n      case WebXRState.ENTERING_XR:\n      // xr is being initialized, enter XR request was made\n      case WebXRState.EXITING_XR:\n      // xr exit request was made. not yet done.\n      case WebXRState.NOT_IN_XR:\n      // either out or not yet in XR\n    }\n  });\n  return xr;\n};\n","import {\n  AssetsManager,\n  Engine,\n  Scene,\n  AbstractMesh,\n  WebXRDefaultExperience,\n  Vector3,\n} from \"@babylonjs/core\";\nimport { CreateSceneClass } from \"../createScene\";\nimport { loadAllAssets } from \"../support/assetManager\";\nimport { setupCamera } from \"../support/camera\";\nimport { setupEnvironment } from \"../support/environment\";\nimport { enableXR } from \"../support/xr\";\n\nexport class MainScreen implements CreateSceneClass {\n  createScene = async (\n    engine: Engine,\n    _canvas: HTMLCanvasElement\n  ): Promise<Scene> => {\n    // Create scene\n    const scene = new Scene(engine);\n\n    // Create AssetManager\n    const assetManager = new AssetsManager(scene);\n\n    engine.displayLoadingUI();\n    // Load up all assets\n    const assets = await loadAllAssets(assetManager, engine.loadingScreen);\n\n    // Setup Camera\n    const camera = setupCamera(scene);\n    camera.rotation.y = -Math.PI;\n\n    // Setup a pipeline\n    const pipeline = setupEnvironment(scene, camera);\n\n    // Setup Floor\n    const groundFloors: AbstractMesh[] = [];\n    const floorAsset = assets.models[\"floor.glb\"];\n    for (const mesh of floorAsset.loadedMeshes) {\n      mesh.checkCollisions = true;\n      mesh.position.y += 0.2;\n      groundFloors.push(mesh);\n    }\n\n    await new Promise<null | WebXRDefaultExperience>(async (resolve) => {\n      try {\n        const xr = await enableXR(scene, groundFloors, pipeline);\n        resolve(xr);\n      } catch (err) {\n        console.log(\"not able to offer VR\");\n        resolve(null);\n      }\n    });\n\n    // engine.hideLoadingUI();\n\n    return scene;\n  };\n}\n\nexport default new MainScreen();\n","import {\n  AssetsManager,\n  BinaryFileAssetTask,\n  ContainerAssetTask,\n  CubeTextureAssetTask,\n  ILoadingScreen,\n  ImageAssetTask,\n  MeshAssetTask,\n  TextureAssetTask,\n} from \"@babylonjs/core\";\nimport { CustomLoadingScreen } from \"./customLoader\";\n\nexport interface AssetsObject {\n  containers: {\n    [key: string]: ContainerAssetTask;\n  };\n  models: {\n    [key: string]: MeshAssetTask;\n  };\n  sounds: {\n    [key: string]: BinaryFileAssetTask;\n  };\n  textures: { [key: string]: TextureAssetTask };\n  images: { [key: string]: ImageAssetTask };\n  cubeTextures: { [key: string]: CubeTextureAssetTask };\n}\n\nexport const loadAllAssets = (\n  assetsManager: AssetsManager,\n  loadingScreen?: ILoadingScreen | CustomLoadingScreen\n): Promise<AssetsObject> =>\n  new Promise((resolve) => {\n    let cubeTextures: string[] = [];\n    let images: string[] = [];\n    let textures: string[] = [];\n    let sounds: string[] = [];\n    let containerModels: string[] = [];\n    let models: string[] = [\"floor.glb\"];\n\n    const assetsContainer: AssetsObject = {\n      models: {},\n      containers: {},\n      textures: {},\n      images: {},\n      sounds: {},\n      cubeTextures: {},\n    };\n\n    for (const model of models) {\n      const modelTask = assetsManager.addMeshTask(\n        model,\n        \"\",\n        \"assets/models/\",\n        model\n      );\n      modelTask.onSuccess = (task) => {\n        assetsContainer.models[model] = task;\n      };\n\n      modelTask.onError = (err) => {\n        console.log(\"model load err: \", err);\n      };\n    }\n\n    for (const container of containerModels) {\n      const containerTask = assetsManager.addContainerTask(\n        container,\n        \"\",\n        `assets/models/`,\n        container\n      );\n      containerTask.onSuccess = (task) => {\n        assetsContainer.containers[container] = task;\n      };\n\n      containerTask.onError = (err) => {\n        console.log(\"container model load err: \", err);\n      };\n    }\n\n    for (const cubeText of cubeTextures) {\n      const cubeTextureTask = assetsManager.addCubeTextureTask(\n        cubeText,\n        `assets/textures/${cubeText}`,\n        undefined,\n        undefined,\n        undefined,\n        true\n      );\n      cubeTextureTask.onSuccess = (task) => {\n        assetsContainer.cubeTextures[cubeText] = task;\n      };\n\n      cubeTextureTask.onError = (err) => {\n        console.log(\"cube texture load err: \", err);\n      };\n    }\n\n    for (const sound of sounds) {\n      const binaryTask = assetsManager.addBinaryFileTask(\n        sound,\n        `assets/sounds/${sound}`\n      );\n      binaryTask.onSuccess = (task) => {\n        assetsContainer.sounds[sound] = task;\n      };\n\n      binaryTask.onError = (err) => {\n        console.log(\"sound load err: \", err);\n      };\n    }\n\n    for (const texture of textures) {\n      const textTask = assetsManager.addTextureTask(\n        texture,\n        `assets/textures/${texture}`,\n        false,\n        false\n      );\n      textTask.onSuccess = (task) => {\n        assetsContainer.textures[texture] = task;\n      };\n\n      textTask.onError = (err) => {\n        console.log(\"texture load err: \", err);\n      };\n    }\n\n    for (const image of images) {\n      const imageTask = assetsManager.addImageTask(\n        image,\n        `assets/images/${image}`\n      );\n      imageTask.onSuccess = (task) => {\n        assetsContainer.images[image] = task;\n      };\n\n      imageTask.onError = (err) => {\n        console.log(\"texture load err: \", err);\n      };\n    }\n\n    assetsManager.onProgress = (remainingCount, totalCount) => {\n      if (!loadingScreen) {\n        return;\n      }\n      const loaded = totalCount - remainingCount;\n      const percent = Number((loaded / totalCount) * 100).toFixed(0);\n      loadingScreen.loadingUIText = `${\n        totalCount - remainingCount\n      } of ${totalCount} loaded`;\n      if (loadingScreen instanceof CustomLoadingScreen) {\n        loadingScreen.progress = `${percent}%`;\n      }\n    };\n    assetsManager.onFinish = (_tasks) => {\n      resolve(assetsContainer);\n    };\n    assetsManager.load();\n  });\n","import { FreeCamera, MeshBuilder, Scene, Vector3 } from \"@babylonjs/core\";\n\nexport const setupCamera = (scene: Scene) => {\n  // This creates the canvas\n  const canvas = scene.getEngine().getRenderingCanvas();\n\n  // Check if camera/player grounded\n  let grounded = false;\n\n  // This creates the camera\n  const camera = new FreeCamera(\"camera\", new Vector3(0, 1.5, 0), scene);\n\n  // This attaches the camera to the canvas\n  camera.attachControl(canvas, true);\n  // Set camera for first person controller\n  camera.applyGravity = true;\n  // Allow checking for collisions\n  camera.checkCollisions = true;\n  // Ellipsoid to provide camera a \"body\"\n  camera.ellipsoid = new Vector3(0.2, 0.8, 0.2);\n  // Camera clipping\n  camera.minZ = 0.01;\n  // Camera \"walking\" speed\n  camera.speed = 0.3;\n  // Reduce sensitivity on movement\n  camera.angularSensibility = 5000;\n\n  // Movement WSAD\n  camera.keysUp.push(87);\n  camera.keysLeft.push(65);\n  camera.keysDown.push(83);\n  camera.keysRight.push(68);\n\n  // body mesh to trigger collisions with other meshes\n  const bodyMesh = MeshBuilder.CreateBox(\"cameraBody\", {\n    height: 2,\n    width: 1,\n  });\n  // hide the body mesh\n  bodyMesh.isVisible = false;\n  // parent the body mesh to the camera\n  bodyMesh.parent = camera;\n\n  // Jump\n  scene.onKeyboardObservable.add((kbinfo) => {\n    if (kbinfo.type === 1 && kbinfo.event.code === \"Space\") {\n      if (grounded) {\n        camera.cameraDirection.y += 0.5;\n        grounded = false;\n      }\n    }\n  });\n\n  // When camera hits something\n  camera.onCollide = (_collidedMesh) => {\n    grounded = true;\n  };\n\n  return camera;\n};\n","import {\n  Camera,\n  CannonJSPlugin,\n  CubeTexture,\n  DefaultRenderingPipeline,\n  HemisphericLight,\n  Scene,\n  Texture,\n  Vector3,\n} from \"@babylonjs/core\";\nimport * as CANNON from \"cannon\";\n\nexport const setupEnvironment = (scene: Scene, camera: Camera) => {\n  // Set the physics engine\n  window.CANNON = CANNON;\n\n  const envText = CubeTexture.CreateFromPrefilteredData(\n    \"assets/textures/canary_wharf.env\",\n    scene\n  );\n\n  // // Fix orientation of the skybox texture\n  envText.coordinatesMode = Texture.SKYBOX_MODE;\n\n  // Creates default HDR environment\n  scene.createDefaultEnvironment({\n    skyboxTexture: envText,\n    skyboxSize: 200,\n    environmentTexture: \"assets/textures/canary_wharf.env\",\n  });\n\n  // add glow layer\n  // const gl = new GlowLayer(\"glow\", scene);\n  // gl.intensity = 0.2;\n\n  // setup pipeline\n  const pipeline = new DefaultRenderingPipeline(\n    \"defaultPipeline\", // The name of the pipeline\n    false, // Do you want the pipeline to use HDR texture?\n    scene, // The scene instance\n    [camera] // The list of cameras to be attached to\n  );\n  pipeline.samples = 4;\n  pipeline.fxaaEnabled = true;\n  pipeline.sharpenEnabled = true;\n  pipeline.sharpen.edgeAmount = 0.9;\n  pipeline.bloomEnabled = true;\n  pipeline.glowLayerEnabled = true;\n\n  if (pipeline.glowLayer) {\n    pipeline.glowLayer.intensity = 0.4;\n  }\n\n  // add a little light\n  const light = new HemisphericLight(\"light\", new Vector3(0, 1, 0), scene);\n  light.intensity = 0.8;\n\n  // setup physics\n  const gravityVector = new Vector3(0, -9.81, 0);\n  scene.enablePhysics(gravityVector, new CannonJSPlugin());\n  scene.collisionsEnabled = true;\n\n  // Set gravity for objects with collisions\n  scene.gravity = new Vector3(0, -0.1, 0);\n  return pipeline;\n};\n"],"names":["enableXR","scene","floorMeshes","pipeline","createDefaultXRExperienceAsync","xr","baseExperience","featuresManager","enableFeature","xrInput","input","physicsProperties","restitution","impostorSize","impostorType","enableHeadsetImpostor","pickBlockerMeshes","observers","meshesUnderPointer","tmpVec","tmpRay","lastTimestamp","oldPos","onControllerAddedObservable","add","inputSource","onMotionControllerInitObservable","motionController","onModelLoadedObservable","_mc","grip","handedness","xr_ids","getComponentIds","getComponent","onButtonStateChangedObservable","pressed","console","log","squeeze","getComponentOfType","changes","getWorldPointerRayToRef","direction","scaleInPlace","position","pointer","meshUnderPointer","pointerSelection","getMeshUnderPointer","uniqueId","physicsImpostor","clone","sessionManager","onXRFrameObservable","delta","currentTimestamp","copyFrom","addInPlace","subtractToRef","setLinearVelocity","setAngularVelocity","remove","onStateChangedObservable","state","cameras","push","camera","createScene","engine","_canvas","assetManager","displayLoadingUI","assetsManager","loadingScreen","Promise","resolve","assetsContainer","models","containers","textures","images","sounds","cubeTextures","model","modelTask","addMeshTask","onSuccess","task","onError","err","container","containerTask","addContainerTask","cubeText","cubeTextureTask","addCubeTextureTask","undefined","sound","binaryTask","addBinaryFileTask","texture","textTask","addTextureTask","image","imageTask","addImageTask","onProgress","remainingCount","totalCount","percent","Number","toFixed","loadingUIText","progress","onFinish","_tasks","load","assets","canvas","getEngine","getRenderingCanvas","grounded","attachControl","applyGravity","checkCollisions","ellipsoid","minZ","speed","angularSensibility","keysUp","keysLeft","keysDown","keysRight","bodyMesh","height","width","isVisible","parent","onKeyboardObservable","kbinfo","type","event","code","cameraDirection","y","onCollide","_collidedMesh","setupCamera","rotation","Math","PI","window","CANNON","envText","coordinatesMode","createDefaultEnvironment","skyboxTexture","skyboxSize","environmentTexture","samples","fxaaEnabled","sharpenEnabled","sharpen","edgeAmount","bloomEnabled","glowLayerEnabled","glowLayer","intensity","gravityVector","enablePhysics","collisionsEnabled","gravity","setupEnvironment","groundFloors","floorAsset","loadedMeshes","mesh","MainScreen"],"sourceRoot":""}