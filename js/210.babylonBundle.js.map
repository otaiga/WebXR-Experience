{"version":3,"file":"js/210.babylonBundle.js","mappings":"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","sources":["webpack://webxrdemo/./src/support/xr.ts","webpack://webxrdemo/./src/scenes/main.ts","webpack://webxrdemo/./src/support/assetManager.ts","webpack://webxrdemo/./src/support/camera.ts","webpack://webxrdemo/./src/support/environment.ts"],"sourcesContent":["import {\n  Scene,\n  WebXRFeatureName,\n  PhysicsImpostor,\n  AbstractMesh,\n  WebXRState,\n  DefaultRenderingPipeline,\n  Vector3,\n  Ray,\n  Animation,\n  BezierCurveEase,\n} from \"@babylonjs/core\";\n\nexport const enableXR = async (\n  scene: Scene,\n  floorMeshes: AbstractMesh[],\n  pipeline?: DefaultRenderingPipeline\n) => {\n  // enable xr\n  const xr = await scene.createDefaultXRExperienceAsync();\n\n  // enable physics for xr\n  xr.baseExperience.featuresManager.enableFeature(\n    WebXRFeatureName.PHYSICS_CONTROLLERS,\n    \"latest\",\n    {\n      xrInput: xr.input,\n      physicsProperties: {\n        restitution: 0.5,\n        impostorSize: 0.1,\n        impostorType: PhysicsImpostor.BoxImpostor,\n      },\n      enableHeadsetImpostor: true,\n    }\n  );\n\n  // teleportation features\n  xr.baseExperience.featuresManager.enableFeature(\n    WebXRFeatureName.TELEPORTATION,\n    \"stable\",\n    {\n      xrInput: xr.input,\n      floorMeshes,\n      pickBlockerMeshes: [],\n    }\n  );\n\n  let observers: any = {};\n  let meshesUnderPointer: any = {};\n  const tmpVec = new Vector3();\n  const tmpRay = new Ray(new Vector3(), new Vector3());\n  let lastTimestamp = 0;\n  const oldPos = new Vector3();\n\n  xr.input.onControllerAddedObservable.add((inputSource) => {\n    inputSource.onMotionControllerInitObservable.add((motionController) => {\n      motionController.onModelLoadedObservable.add(async (_mc) => {\n        const mesh = inputSource.grip;\n        if (mesh && motionController.handedness === \"left\") {\n          const xr_ids = motionController.getComponentIds();\n          // get x button\n          const xbuttonComponent = motionController.getComponent(xr_ids[3]);\n          xbuttonComponent.onButtonStateChangedObservable.add(() => {\n            if (xbuttonComponent.pressed) {\n              console.log(\"X pressed!\");\n            }\n          });\n        }\n\n        const squeeze = motionController.getComponentOfType(\"squeeze\");\n        if (squeeze) {\n          squeeze.onButtonStateChangedObservable.add(() => {\n            if (squeeze.changes.pressed) {\n              if (squeeze.pressed) {\n                inputSource.getWorldPointerRayToRef(tmpRay, true);\n                tmpRay.direction.scaleInPlace(1.5);\n                const position = inputSource.grip\n                  ? inputSource.grip.position\n                  : inputSource.pointer.position;\n                let mesh = scene.meshUnderPointer;\n                if (xr.pointerSelection.getMeshUnderPointer) {\n                  mesh = xr.pointerSelection.getMeshUnderPointer(\n                    inputSource.uniqueId\n                  );\n                }\n                if (\n                  mesh &&\n                  mesh.physicsImpostor &&\n                  mesh.name !== \"Floor\" &&\n                  mesh.name !== \"Ground\"\n                ) {\n                  Animation.CreateAndStartAnimation(\n                    \"meshmove\",\n                    mesh,\n                    \"position\",\n                    30,\n                    15,\n                    mesh.position.clone(),\n                    position.add(tmpRay.direction),\n                    Animation.ANIMATIONLOOPMODE_CONSTANT,\n                    new BezierCurveEase(0.3, -0.75, 0.7, 1.6),\n                    () => {\n                      if (!mesh) return;\n                      meshesUnderPointer[inputSource.uniqueId] = mesh;\n                      observers[inputSource.uniqueId] =\n                        xr.baseExperience.sessionManager.onXRFrameObservable.add(\n                          () => {\n                            const delta =\n                              xr.baseExperience.sessionManager\n                                .currentTimestamp - lastTimestamp;\n                            lastTimestamp =\n                              xr.baseExperience.sessionManager.currentTimestamp;\n                            inputSource.getWorldPointerRayToRef(tmpRay, true);\n                            tmpRay.direction.scaleInPlace(1.5);\n                            const position = inputSource.grip\n                              ? inputSource.grip.position\n                              : inputSource.pointer.position;\n                            tmpVec.copyFrom(position);\n                            tmpVec.addInPlace(tmpRay.direction);\n                            tmpVec.subtractToRef(oldPos, tmpVec);\n                            tmpVec.scaleInPlace(1000 / delta);\n                            meshesUnderPointer[\n                              inputSource.uniqueId\n                            ].position.copyFrom(position);\n                            meshesUnderPointer[\n                              inputSource.uniqueId\n                            ].position.addInPlace(tmpRay.direction);\n                            oldPos.copyFrom(\n                              meshesUnderPointer[inputSource.uniqueId].position\n                            );\n                            meshesUnderPointer[\n                              inputSource.uniqueId\n                            ].physicsImpostor.setLinearVelocity(Vector3.Zero());\n                            meshesUnderPointer[\n                              inputSource.uniqueId\n                            ].physicsImpostor.setAngularVelocity(\n                              Vector3.Zero()\n                            );\n                          }\n                        );\n                    }\n                  );\n                }\n              } else {\n                // throw the object\n                if (\n                  observers[inputSource.uniqueId] &&\n                  meshesUnderPointer[inputSource.uniqueId]\n                ) {\n                  xr.baseExperience.sessionManager.onXRFrameObservable.remove(\n                    observers[inputSource.uniqueId]\n                  );\n                  observers[inputSource.uniqueId] = null;\n                  meshesUnderPointer[\n                    inputSource.uniqueId\n                  ].physicsImpostor.setLinearVelocity(tmpVec);\n                }\n              }\n            }\n          });\n        }\n      });\n    });\n  });\n\n  xr.baseExperience.onStateChangedObservable.add((state) => {\n    switch (state) {\n      case WebXRState.IN_XR:\n        // XR is initialized and already submitted one frame\n        if (pipeline) {\n          pipeline.cameras.push(xr.baseExperience.camera);\n        }\n      case WebXRState.ENTERING_XR:\n      // xr is being initialized, enter XR request was made\n      case WebXRState.EXITING_XR:\n      // xr exit request was made. not yet done.\n      case WebXRState.NOT_IN_XR:\n      // either out or not yet in XR\n    }\n  });\n  return xr;\n};\n","import {\n  AssetsManager,\n  Engine,\n  Scene,\n  AbstractMesh,\n  WebXRDefaultExperience,\n  Vector3,\n  PhysicsImpostor,\n  MeshBuilder,\n} from \"@babylonjs/core\";\nimport { CreateSceneClass } from \"../createScene\";\nimport { loadAllAssets } from \"../support/assetManager\";\nimport { setupCamera } from \"../support/camera\";\nimport { setupEnvironment } from \"../support/environment\";\nimport { enableXR } from \"../support/xr\";\n\nexport class MainScreen implements CreateSceneClass {\n  createScene = async (\n    engine: Engine,\n    _canvas: HTMLCanvasElement\n  ): Promise<Scene> => {\n    // Create scene\n    const scene = new Scene(engine);\n\n    // Create AssetManager\n    const assetManager = new AssetsManager(scene);\n\n    engine.displayLoadingUI();\n    // Load up all assets\n    const assets = await loadAllAssets(assetManager, engine.loadingScreen);\n\n    // Setup Camera\n    const camera = setupCamera(scene);\n    camera.rotation.y = -Math.PI;\n\n    // Setup a pipeline\n    const pipeline = setupEnvironment(scene, camera);\n\n    // Get snow material\n    const snowMat = scene.materials.find((mat) => mat.name === \"Snow\");\n\n    // Setup Floor\n    const groundFloors: AbstractMesh[] = [];\n\n    const createSnowBall = () => {\n      const sb = MeshBuilder.CreateSphere(\"snowball\", { diameter: 0.3 });\n      sb.physicsImpostor = new PhysicsImpostor(\n        sb,\n        PhysicsImpostor.SphereImpostor,\n        {\n          mass: 1,\n          restitution: 0.9,\n        },\n        scene\n      );\n      sb.position = new Vector3(0, 1, -4);\n      if (snowMat) {\n        sb.material = snowMat;\n      }\n    };\n\n    const ground = MeshBuilder.CreateGround(\"ground\", {\n      width: 100,\n      height: 100,\n      subdivisions: 20,\n    });\n    ground.receiveShadows = true;\n    ground.position = new Vector3(0, 0, 0);\n    ground.checkCollisions = true;\n    ground.physicsImpostor = new PhysicsImpostor(\n      ground,\n      PhysicsImpostor.BoxImpostor,\n      {\n        mass: 0,\n        friction: 0.8,\n        restitution: 0.5,\n        disableBidirectionalTransformation: true,\n      },\n      scene\n    );\n    groundFloors.push(ground);\n    if (snowMat) {\n      ground.material = snowMat;\n    }\n\n    createSnowBall();\n\n    await new Promise<null | WebXRDefaultExperience>(async (resolve) => {\n      try {\n        const xr = await enableXR(scene, groundFloors, pipeline);\n        resolve(xr);\n      } catch (err) {\n        console.log(\"not able to offer VR\");\n        resolve(null);\n      }\n    });\n\n    // window.addEventListener(\"keydown\", async (ev) => {\n    //   // debugger Ctrl+Alt+I\n    //   if (ev.ctrlKey && ev.altKey && ev.code === \"KeyI\") {\n    //     await runDebugger(scene);\n    //   }\n    // });\n\n    return scene;\n  };\n}\n\nexport default new MainScreen();\n","import {\n  AssetsManager,\n  BinaryFileAssetTask,\n  ContainerAssetTask,\n  CubeTextureAssetTask,\n  ILoadingScreen,\n  ImageAssetTask,\n  MeshAssetTask,\n  TextureAssetTask,\n} from \"@babylonjs/core\";\nimport { CustomLoadingScreen } from \"./customLoader\";\n\nexport interface AssetsObject {\n  containers: {\n    [key: string]: ContainerAssetTask;\n  };\n  models: {\n    [key: string]: MeshAssetTask;\n  };\n  sounds: {\n    [key: string]: BinaryFileAssetTask;\n  };\n  textures: { [key: string]: TextureAssetTask };\n  images: { [key: string]: ImageAssetTask };\n  cubeTextures: { [key: string]: CubeTextureAssetTask };\n}\n\nexport const loadAllAssets = (\n  assetsManager: AssetsManager,\n  loadingScreen?: ILoadingScreen | CustomLoadingScreen\n): Promise<AssetsObject> =>\n  new Promise((resolve) => {\n    let cubeTextures: string[] = [];\n    let images: string[] = [];\n    let textures: string[] = [];\n    let sounds: string[] = [];\n    let containerModels: string[] = [];\n    let models: string[] = [\"snowScene.glb\"];\n\n    const assetsContainer: AssetsObject = {\n      models: {},\n      containers: {},\n      textures: {},\n      images: {},\n      sounds: {},\n      cubeTextures: {},\n    };\n\n    for (const model of models) {\n      const modelTask = assetsManager.addMeshTask(\n        model,\n        \"\",\n        `${window.location.href}assets/models/`,\n        model\n      );\n      modelTask.onSuccess = (task) => {\n        assetsContainer.models[model] = task;\n      };\n\n      modelTask.onError = (err) => {\n        console.log(\"model load err: \", err);\n      };\n    }\n\n    for (const container of containerModels) {\n      const containerTask = assetsManager.addContainerTask(\n        container,\n        \"\",\n        `${window.location.href}assets/models/`,\n        container\n      );\n      containerTask.onSuccess = (task) => {\n        assetsContainer.containers[container] = task;\n      };\n\n      containerTask.onError = (err) => {\n        console.log(\"container model load err: \", err);\n      };\n    }\n\n    for (const cubeText of cubeTextures) {\n      const cubeTextureTask = assetsManager.addCubeTextureTask(\n        cubeText,\n        `${window.location.href}assets/textures/${cubeText}`,\n        undefined,\n        undefined,\n        undefined,\n        true\n      );\n      cubeTextureTask.onSuccess = (task) => {\n        assetsContainer.cubeTextures[cubeText] = task;\n      };\n\n      cubeTextureTask.onError = (err) => {\n        console.log(\"cube texture load err: \", err);\n      };\n    }\n\n    for (const sound of sounds) {\n      const binaryTask = assetsManager.addBinaryFileTask(\n        sound,\n        `${window.location.href}assets/sounds/${sound}`\n      );\n      binaryTask.onSuccess = (task) => {\n        assetsContainer.sounds[sound] = task;\n      };\n\n      binaryTask.onError = (err) => {\n        console.log(\"sound load err: \", err);\n      };\n    }\n\n    for (const texture of textures) {\n      const textTask = assetsManager.addTextureTask(\n        texture,\n        `${window.location.href}assets/textures/${texture}`,\n        false,\n        false\n      );\n      textTask.onSuccess = (task) => {\n        assetsContainer.textures[texture] = task;\n      };\n\n      textTask.onError = (err) => {\n        console.log(\"texture load err: \", err);\n      };\n    }\n\n    for (const image of images) {\n      const imageTask = assetsManager.addImageTask(\n        image,\n        `${window.location.href}assets/images/${image}`\n      );\n      imageTask.onSuccess = (task) => {\n        assetsContainer.images[image] = task;\n      };\n\n      imageTask.onError = (err) => {\n        console.log(\"texture load err: \", err);\n      };\n    }\n\n    assetsManager.onProgress = (remainingCount, totalCount) => {\n      if (!loadingScreen) {\n        return;\n      }\n      const loaded = totalCount - remainingCount;\n      const percent = Number((loaded / totalCount) * 100).toFixed(0);\n      loadingScreen.loadingUIText = `${\n        totalCount - remainingCount\n      } of ${totalCount} loaded`;\n      if (loadingScreen instanceof CustomLoadingScreen) {\n        loadingScreen.progress = `${percent}%`;\n      }\n    };\n    assetsManager.onFinish = (_tasks) => {\n      resolve(assetsContainer);\n    };\n    assetsManager.load();\n  });\n","import { FreeCamera, MeshBuilder, Scene, Vector3 } from \"@babylonjs/core\";\n\nexport const setupCamera = (scene: Scene) => {\n  // This creates the canvas\n  const canvas = scene.getEngine().getRenderingCanvas();\n\n  // Check if camera/player grounded\n  let grounded = false;\n\n  // This creates the camera\n  const camera = new FreeCamera(\"camera\", new Vector3(0, 1.5, 0), scene);\n\n  // This attaches the camera to the canvas\n  camera.attachControl(canvas, true);\n  // Set camera for first person controller\n  camera.applyGravity = true;\n  // Allow checking for collisions\n  camera.checkCollisions = true;\n  // Ellipsoid to provide camera a \"body\"\n  camera.ellipsoid = new Vector3(0.2, 0.8, 0.2);\n  // Camera clipping\n  camera.minZ = 0.01;\n  // Camera \"walking\" speed\n  camera.speed = 0.3;\n  // Reduce sensitivity on movement\n  camera.angularSensibility = 5000;\n\n  // Movement WSAD\n  camera.keysUp.push(87);\n  camera.keysLeft.push(65);\n  camera.keysDown.push(83);\n  camera.keysRight.push(68);\n\n  // body mesh to trigger collisions with other meshes\n  const bodyMesh = MeshBuilder.CreateBox(\"cameraBody\", {\n    height: 2,\n    width: 1,\n  });\n  // hide the body mesh\n  bodyMesh.isVisible = false;\n  // parent the body mesh to the camera\n  bodyMesh.parent = camera;\n\n  // Jump\n  scene.onKeyboardObservable.add((kbinfo) => {\n    if (kbinfo.type === 1 && kbinfo.event.code === \"Space\") {\n      if (grounded) {\n        camera.cameraDirection.y += 0.5;\n        grounded = false;\n      }\n    }\n  });\n\n  // When camera hits something\n  camera.onCollide = (_collidedMesh) => {\n    grounded = true;\n  };\n\n  return camera;\n};\n","import {\n  Camera,\n  CannonJSPlugin,\n  CubeTexture,\n  DefaultRenderingPipeline,\n  HemisphericLight,\n  Scene,\n  Texture,\n  Vector3,\n} from \"@babylonjs/core\";\nimport * as CANNON from \"cannon\";\n\nexport const setupEnvironment = (scene: Scene, camera: Camera) => {\n  // Set the physics engine\n  window.CANNON = CANNON;\n\n  const envTexturePath = \"assets/textures/snowy_park.env\";\n\n  const envText = CubeTexture.CreateFromPrefilteredData(envTexturePath, scene);\n\n  // // Fix orientation of the skybox texture\n  envText.coordinatesMode = Texture.SKYBOX_MODE;\n\n  // Creates default HDR environment\n  scene.createDefaultEnvironment({\n    skyboxTexture: envText,\n    skyboxSize: 200,\n    environmentTexture: envTexturePath,\n  });\n\n  // add glow layer\n  // const gl = new GlowLayer(\"glow\", scene);\n  // gl.intensity = 0.2;\n\n  // setup pipeline\n  const pipeline = new DefaultRenderingPipeline(\n    \"defaultPipeline\", // The name of the pipeline\n    false, // Do you want the pipeline to use HDR texture?\n    scene, // The scene instance\n    [camera] // The list of cameras to be attached to\n  );\n  pipeline.samples = 4;\n  pipeline.fxaaEnabled = true;\n  pipeline.sharpenEnabled = true;\n  pipeline.sharpen.edgeAmount = 0.9;\n  pipeline.bloomEnabled = true;\n  pipeline.glowLayerEnabled = true;\n\n  if (pipeline.glowLayer) {\n    pipeline.glowLayer.intensity = 0.4;\n  }\n\n  // add a little light\n  const light = new HemisphericLight(\"light\", new Vector3(0, 1, 0), scene);\n  light.intensity = 0.8;\n\n  // setup physics\n  const gravityVector = new Vector3(0, -9.81, 0);\n  scene.enablePhysics(gravityVector, new CannonJSPlugin());\n  scene.collisionsEnabled = true;\n\n  // Set gravity for objects with collisions\n  scene.gravity = new Vector3(0, -0.1, 0);\n  return pipeline;\n};\n"],"names":["enableXR","scene","floorMeshes","pipeline","createDefaultXRExperienceAsync","xr","baseExperience","featuresManager","enableFeature","xrInput","input","physicsProperties","restitution","impostorSize","impostorType","enableHeadsetImpostor","pickBlockerMeshes","observers","meshesUnderPointer","tmpVec","tmpRay","lastTimestamp","oldPos","onControllerAddedObservable","add","inputSource","onMotionControllerInitObservable","motionController","onModelLoadedObservable","_mc","grip","handedness","xr_ids","getComponentIds","getComponent","onButtonStateChangedObservable","pressed","console","log","squeeze","getComponentOfType","changes","getWorldPointerRayToRef","direction","scaleInPlace","position","pointer","meshUnderPointer","pointerSelection","getMeshUnderPointer","uniqueId","physicsImpostor","name","clone","sessionManager","onXRFrameObservable","delta","currentTimestamp","copyFrom","addInPlace","subtractToRef","setLinearVelocity","setAngularVelocity","remove","onStateChangedObservable","state","cameras","push","camera","createScene","engine","_canvas","assetManager","displayLoadingUI","assetsManager","loadingScreen","Promise","resolve","assetsContainer","models","containers","textures","images","sounds","cubeTextures","model","modelTask","addMeshTask","window","location","href","onSuccess","task","onError","err","container","containerTask","addContainerTask","cubeText","cubeTextureTask","addCubeTextureTask","undefined","sound","binaryTask","addBinaryFileTask","texture","textTask","addTextureTask","image","imageTask","addImageTask","onProgress","remainingCount","totalCount","percent","Number","toFixed","loadingUIText","progress","onFinish","_tasks","load","canvas","getEngine","getRenderingCanvas","grounded","attachControl","applyGravity","checkCollisions","ellipsoid","minZ","speed","angularSensibility","keysUp","keysLeft","keysDown","keysRight","bodyMesh","height","width","isVisible","parent","onKeyboardObservable","kbinfo","type","event","code","cameraDirection","y","onCollide","_collidedMesh","setupCamera","rotation","Math","PI","CANNON","envTexturePath","envText","coordinatesMode","createDefaultEnvironment","skyboxTexture","skyboxSize","environmentTexture","samples","fxaaEnabled","sharpenEnabled","sharpen","edgeAmount","bloomEnabled","glowLayerEnabled","glowLayer","intensity","gravityVector","enablePhysics","collisionsEnabled","gravity","setupEnvironment","snowMat","materials","find","mat","groundFloors","createSnowBall","sb","diameter","mass","material","ground","subdivisions","receiveShadows","friction","disableBidirectionalTransformation","MainScreen"],"sourceRoot":""}