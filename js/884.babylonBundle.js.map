{"version":3,"file":"js/884.babylonBundle.js","mappings":"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","sources":["webpack://webxrdemo/./src/support/debugger.ts","webpack://webxrdemo/./src/support/utils.ts","webpack://webxrdemo/./src/support/xr.ts","webpack://webxrdemo/./src/scenes/main.ts","webpack://webxrdemo/./src/support/assetManager.ts","webpack://webxrdemo/./src/support/camera.ts","webpack://webxrdemo/./src/support/environment.ts"],"sourcesContent":["import { Scene } from \"@babylonjs/core\";\n\nlet importedDebugger = false;\nexport const runDebugger = async (scene: Scene) => {\n  if (!importedDebugger) {\n    await import(\"@babylonjs/core/Debug/debugLayer\");\n    await import(\"@babylonjs/inspector\");\n    importedDebugger = true;\n  }\n  if (scene.debugLayer?.isVisible()) {\n    scene.debugLayer?.hide();\n  } else {\n    try {\n      await scene.debugLayer?.show();\n    } catch (err) {\n      console.log(err);\n    }\n  }\n};\n","import {\n  AbstractMesh,\n  MeshBuilder,\n  PhysicsImpostor,\n  Scene,\n  SixDofDragBehavior,\n  Vector3,\n} from \"@babylonjs/core\";\n\nexport const createSixDegreesOfDrag = (mesh: AbstractMesh) => {\n  const sixdof = new SixDofDragBehavior();\n  sixdof.onDragStartObservable.add(() => {\n    if (mesh.physicsImpostor) {\n      mesh.physicsImpostor.sleep();\n    }\n  });\n  sixdof.onDragEndObservable.add(() => {\n    if (mesh.physicsImpostor) {\n      mesh.physicsImpostor.wakeUp();\n    }\n  });\n  return sixdof;\n};\n\nexport const createSnowBall = (scene: Scene) => {\n  const snowMat = scene.materials.find((mat) => mat.name === \"Snow\");\n  const sb = MeshBuilder.CreateSphere(\"snowball\", { diameter: 0.3 });\n  sb.physicsImpostor = new PhysicsImpostor(\n    sb,\n    PhysicsImpostor.SphereImpostor,\n    {\n      mass: 1,\n      restitution: 0.9,\n    },\n    scene\n  );\n  sb.position = new Vector3(0, 0.4, -4);\n  if (snowMat) {\n    sb.material = snowMat;\n  }\n  createSixDegreesOfDrag(sb);\n  sb.addBehavior(createSixDegreesOfDrag(sb));\n  sb.onCollide = (collidedMesh) => {\n    if (collidedMesh?.name === \"deadzone\") {\n      sb.dispose();\n    }\n  };\n};\n","import {\n  Scene,\n  WebXRFeatureName,\n  PhysicsImpostor,\n  AbstractMesh,\n  WebXRState,\n  DefaultRenderingPipeline,\n  Vector3,\n  Ray,\n  Animation,\n  BezierCurveEase,\n} from \"@babylonjs/core\";\nimport { createSnowBall } from \"./utils\";\n\nexport const enableXR = async (\n  scene: Scene,\n  floorMeshes: AbstractMesh[],\n  pipeline?: DefaultRenderingPipeline\n) => {\n  // enable xr\n  const xr = await scene.createDefaultXRExperienceAsync();\n\n  // enable physics for xr\n  xr.baseExperience.featuresManager.enableFeature(\n    WebXRFeatureName.PHYSICS_CONTROLLERS,\n    \"latest\",\n    {\n      xrInput: xr.input,\n      physicsProperties: {\n        restitution: 0.5,\n        impostorSize: 0.1,\n        impostorType: PhysicsImpostor.BoxImpostor,\n      },\n      enableHeadsetImpostor: true,\n    }\n  );\n\n  // teleportation features\n  xr.baseExperience.featuresManager.enableFeature(\n    WebXRFeatureName.TELEPORTATION,\n    \"stable\",\n    {\n      xrInput: xr.input,\n      floorMeshes,\n      pickBlockerMeshes: [],\n    }\n  );\n\n  let observers: any = {};\n  let meshesUnderPointer: any = {};\n  const tmpVec = new Vector3();\n  const tmpRay = new Ray(new Vector3(), new Vector3());\n  let lastTimestamp = 0;\n  const oldPos = new Vector3();\n\n  xr.input.onControllerAddedObservable.add((inputSource) => {\n    inputSource.onMotionControllerInitObservable.add((motionController) => {\n      motionController.onModelLoadedObservable.add(async (_mc) => {\n        const mesh = inputSource.grip;\n        if (mesh && motionController.handedness === \"left\") {\n          const xr_ids = motionController.getComponentIds();\n          // get x button\n          const xbuttonComponent = motionController.getComponent(xr_ids[3]);\n          xbuttonComponent.onButtonStateChangedObservable.add(() => {\n            if (xbuttonComponent.pressed) {\n              console.log(\"X pressed!\");\n            }\n          });\n        }\n\n        const squeeze = motionController.getComponentOfType(\"squeeze\");\n        if (squeeze) {\n          squeeze.onButtonStateChangedObservable.add(() => {\n            if (squeeze.changes.pressed) {\n              if (squeeze.pressed) {\n                inputSource.getWorldPointerRayToRef(tmpRay, true);\n                tmpRay.direction.scaleInPlace(1.5);\n                const position = inputSource.grip\n                  ? inputSource.grip.position\n                  : inputSource.pointer.position;\n                let mesh = scene.meshUnderPointer;\n                if (xr.pointerSelection.getMeshUnderPointer) {\n                  mesh = xr.pointerSelection.getMeshUnderPointer(\n                    inputSource.uniqueId\n                  );\n                }\n                if (\n                  mesh &&\n                  mesh.physicsImpostor &&\n                  mesh.name !== \"Floor\" &&\n                  mesh.name !== \"Ground\"\n                ) {\n                  Animation.CreateAndStartAnimation(\n                    \"meshmove\",\n                    mesh,\n                    \"position\",\n                    30,\n                    15,\n                    mesh.position.clone(),\n                    position.add(tmpRay.direction),\n                    Animation.ANIMATIONLOOPMODE_CONSTANT,\n                    new BezierCurveEase(0.3, -0.75, 0.7, 1.6),\n                    () => {\n                      if (!mesh) return;\n                      meshesUnderPointer[inputSource.uniqueId] = mesh;\n                      observers[inputSource.uniqueId] =\n                        xr.baseExperience.sessionManager.onXRFrameObservable.add(\n                          () => {\n                            const delta =\n                              xr.baseExperience.sessionManager\n                                .currentTimestamp - lastTimestamp;\n                            lastTimestamp =\n                              xr.baseExperience.sessionManager.currentTimestamp;\n                            inputSource.getWorldPointerRayToRef(tmpRay, true);\n                            tmpRay.direction.scaleInPlace(1.5);\n                            const position = inputSource.grip\n                              ? inputSource.grip.position\n                              : inputSource.pointer.position;\n                            tmpVec.copyFrom(position);\n                            tmpVec.addInPlace(tmpRay.direction);\n                            tmpVec.subtractToRef(oldPos, tmpVec);\n                            tmpVec.scaleInPlace(1000 / delta);\n                            meshesUnderPointer[\n                              inputSource.uniqueId\n                            ].position.copyFrom(position);\n                            meshesUnderPointer[\n                              inputSource.uniqueId\n                            ].position.addInPlace(tmpRay.direction);\n                            oldPos.copyFrom(\n                              meshesUnderPointer[inputSource.uniqueId].position\n                            );\n                            meshesUnderPointer[\n                              inputSource.uniqueId\n                            ].physicsImpostor.setLinearVelocity(Vector3.Zero());\n                            meshesUnderPointer[\n                              inputSource.uniqueId\n                            ].physicsImpostor.setAngularVelocity(\n                              Vector3.Zero()\n                            );\n                          }\n                        );\n                    }\n                  );\n                }\n              } else {\n                // throw the object\n                if (\n                  observers[inputSource.uniqueId] &&\n                  meshesUnderPointer[inputSource.uniqueId]\n                ) {\n                  setTimeout(() => {\n                    const snowballs = scene.meshes.filter(\n                      (mesh) => mesh.name === \"snowball\"\n                    );\n                    for (const snowball of snowballs) {\n                      snowball.dispose();\n                    }\n                    createSnowBall(scene);\n                  }, 2000);\n                  xr.baseExperience.sessionManager.onXRFrameObservable.remove(\n                    observers[inputSource.uniqueId]\n                  );\n                  observers[inputSource.uniqueId] = null;\n                  meshesUnderPointer[\n                    inputSource.uniqueId\n                  ].physicsImpostor.setLinearVelocity(tmpVec);\n                }\n              }\n            }\n          });\n        }\n      });\n    });\n  });\n\n  xr.baseExperience.onStateChangedObservable.add((state) => {\n    switch (state) {\n      case WebXRState.IN_XR:\n        // XR is initialized and already submitted one frame\n        if (pipeline) {\n          pipeline.cameras.push(xr.baseExperience.camera);\n        }\n      case WebXRState.ENTERING_XR:\n      // xr is being initialized, enter XR request was made\n      case WebXRState.EXITING_XR:\n      // xr exit request was made. not yet done.\n      case WebXRState.NOT_IN_XR:\n      // either out or not yet in XR\n    }\n  });\n  return xr;\n};\n","import {\n  AssetsManager,\n  Engine,\n  Scene,\n  AbstractMesh,\n  WebXRDefaultExperience,\n  Vector3,\n  PhysicsImpostor,\n  MeshBuilder,\n} from \"@babylonjs/core\";\nimport { CreateSceneClass } from \"../createScene\";\nimport { loadAllAssets } from \"../support/assetManager\";\nimport { setupCamera } from \"../support/camera\";\nimport { runDebugger } from \"../support/debugger\";\nimport { setupEnvironment } from \"../support/environment\";\nimport { createSixDegreesOfDrag, createSnowBall } from \"../support/utils\";\nimport { enableXR } from \"../support/xr\";\n\nexport class MainScreen implements CreateSceneClass {\n  createScene = async (\n    engine: Engine,\n    _canvas: HTMLCanvasElement\n  ): Promise<Scene> => {\n    // Create scene\n    const scene = new Scene(engine);\n\n    // Create AssetManager\n    const assetManager = new AssetsManager(scene);\n\n    engine.displayLoadingUI();\n    // Load up all assets\n    const assets = await loadAllAssets(assetManager, engine.loadingScreen);\n\n    const snowScene = assets.models[\"snowScene.glb\"];\n    if (snowScene) {\n      for (const mesh of snowScene.loadedMeshes) {\n        mesh.checkCollisions = true;\n      }\n    }\n\n    // Setup Camera\n    const camera = setupCamera(scene);\n    camera.rotation.y = -Math.PI;\n\n    // Setup a pipeline\n    const pipeline = setupEnvironment(scene, camera);\n\n    // Get snow material\n    const snowMat = scene.materials.find((mat) => mat.name === \"Snow\");\n\n    // Setup Floor\n    const groundFloors: AbstractMesh[] = [];\n\n    const ground = MeshBuilder.CreateGround(\"ground\", {\n      width: 50,\n      height: 50,\n      subdivisions: 20,\n    });\n    ground.receiveShadows = true;\n    ground.position = new Vector3(0, 0, 0);\n    ground.checkCollisions = true;\n    ground.physicsImpostor = new PhysicsImpostor(\n      ground,\n      PhysicsImpostor.BoxImpostor,\n      {\n        mass: 0,\n        friction: 0.8,\n        restitution: 0.5,\n        disableBidirectionalTransformation: true,\n      },\n      scene\n    );\n    groundFloors.push(ground);\n    if (snowMat) {\n      ground.material = snowMat;\n    }\n\n    const deadZone = MeshBuilder.CreateGround(\"deadzone\", {\n      width: 200,\n      height: 200,\n      subdivisions: 20,\n    });\n\n    deadZone.checkCollisions = true;\n    deadZone.position = new Vector3(0, -1, 0);\n    deadZone.isVisible = false;\n\n    createSnowBall(scene);\n\n    await new Promise<null | WebXRDefaultExperience>(async (resolve) => {\n      try {\n        const xr = await enableXR(scene, groundFloors, pipeline);\n        resolve(xr);\n      } catch (err) {\n        console.log(\"not able to offer VR\");\n        resolve(null);\n      }\n    });\n\n    window.addEventListener(\"keydown\", async (ev) => {\n      // debugger Ctrl+Alt+I\n      if (ev.ctrlKey && ev.altKey && ev.code === \"KeyI\") {\n        await runDebugger(scene);\n      }\n    });\n\n    return scene;\n  };\n}\n\nexport default new MainScreen();\n","import {\n  AssetsManager,\n  BinaryFileAssetTask,\n  ContainerAssetTask,\n  CubeTextureAssetTask,\n  ILoadingScreen,\n  ImageAssetTask,\n  MeshAssetTask,\n  TextureAssetTask,\n} from \"@babylonjs/core\";\nimport { CustomLoadingScreen } from \"./customLoader\";\n\nexport interface AssetsObject {\n  containers: {\n    [key: string]: ContainerAssetTask;\n  };\n  models: {\n    [key: string]: MeshAssetTask;\n  };\n  sounds: {\n    [key: string]: BinaryFileAssetTask;\n  };\n  textures: { [key: string]: TextureAssetTask };\n  images: { [key: string]: ImageAssetTask };\n  cubeTextures: { [key: string]: CubeTextureAssetTask };\n}\n\nexport const loadAllAssets = (\n  assetsManager: AssetsManager,\n  loadingScreen?: ILoadingScreen | CustomLoadingScreen\n): Promise<AssetsObject> =>\n  new Promise((resolve) => {\n    let cubeTextures: string[] = [];\n    let images: string[] = [];\n    let textures: string[] = [];\n    let sounds: string[] = [];\n    let containerModels: string[] = [];\n    let models: string[] = [\"snowScene.glb\"];\n\n    const assetsContainer: AssetsObject = {\n      models: {},\n      containers: {},\n      textures: {},\n      images: {},\n      sounds: {},\n      cubeTextures: {},\n    };\n\n    for (const model of models) {\n      const modelTask = assetsManager.addMeshTask(\n        model,\n        \"\",\n        `${window.location.href}assets/models/`,\n        model\n      );\n      modelTask.onSuccess = (task) => {\n        assetsContainer.models[model] = task;\n      };\n\n      modelTask.onError = (err) => {\n        console.log(\"model load err: \", err);\n      };\n    }\n\n    for (const container of containerModels) {\n      const containerTask = assetsManager.addContainerTask(\n        container,\n        \"\",\n        `${window.location.href}assets/models/`,\n        container\n      );\n      containerTask.onSuccess = (task) => {\n        assetsContainer.containers[container] = task;\n      };\n\n      containerTask.onError = (err) => {\n        console.log(\"container model load err: \", err);\n      };\n    }\n\n    for (const cubeText of cubeTextures) {\n      const cubeTextureTask = assetsManager.addCubeTextureTask(\n        cubeText,\n        `${window.location.href}assets/textures/${cubeText}`,\n        undefined,\n        undefined,\n        undefined,\n        true\n      );\n      cubeTextureTask.onSuccess = (task) => {\n        assetsContainer.cubeTextures[cubeText] = task;\n      };\n\n      cubeTextureTask.onError = (err) => {\n        console.log(\"cube texture load err: \", err);\n      };\n    }\n\n    for (const sound of sounds) {\n      const binaryTask = assetsManager.addBinaryFileTask(\n        sound,\n        `${window.location.href}assets/sounds/${sound}`\n      );\n      binaryTask.onSuccess = (task) => {\n        assetsContainer.sounds[sound] = task;\n      };\n\n      binaryTask.onError = (err) => {\n        console.log(\"sound load err: \", err);\n      };\n    }\n\n    for (const texture of textures) {\n      const textTask = assetsManager.addTextureTask(\n        texture,\n        `${window.location.href}assets/textures/${texture}`,\n        false,\n        false\n      );\n      textTask.onSuccess = (task) => {\n        assetsContainer.textures[texture] = task;\n      };\n\n      textTask.onError = (err) => {\n        console.log(\"texture load err: \", err);\n      };\n    }\n\n    for (const image of images) {\n      const imageTask = assetsManager.addImageTask(\n        image,\n        `${window.location.href}assets/images/${image}`\n      );\n      imageTask.onSuccess = (task) => {\n        assetsContainer.images[image] = task;\n      };\n\n      imageTask.onError = (err) => {\n        console.log(\"texture load err: \", err);\n      };\n    }\n\n    assetsManager.onProgress = (remainingCount, totalCount) => {\n      if (!loadingScreen) {\n        return;\n      }\n      const loaded = totalCount - remainingCount;\n      const percent = Number((loaded / totalCount) * 100).toFixed(0);\n      loadingScreen.loadingUIText = `${\n        totalCount - remainingCount\n      } of ${totalCount} loaded`;\n      if (loadingScreen instanceof CustomLoadingScreen) {\n        loadingScreen.progress = `${percent}%`;\n      }\n    };\n    assetsManager.onFinish = (_tasks) => {\n      resolve(assetsContainer);\n    };\n    assetsManager.load();\n  });\n","import { FreeCamera, MeshBuilder, Scene, Vector3 } from \"@babylonjs/core\";\n\nexport const setupCamera = (scene: Scene) => {\n  // This creates the canvas\n  const canvas = scene.getEngine().getRenderingCanvas();\n\n  // Check if camera/player grounded\n  let grounded = false;\n\n  // This creates the camera\n  const camera = new FreeCamera(\"camera\", new Vector3(0, 1.5, 0), scene);\n\n  // This attaches the camera to the canvas\n  camera.attachControl(canvas, true);\n  // Set camera for first person controller\n  camera.applyGravity = true;\n  // Allow checking for collisions\n  camera.checkCollisions = true;\n  // Ellipsoid to provide camera a \"body\"\n  camera.ellipsoid = new Vector3(0.2, 0.8, 0.2);\n  // Camera clipping\n  camera.minZ = 0.01;\n  // Camera \"walking\" speed\n  camera.speed = 0.3;\n  // Reduce sensitivity on movement\n  camera.angularSensibility = 5000;\n\n  // Movement WSAD\n  camera.keysUp.push(87);\n  camera.keysLeft.push(65);\n  camera.keysDown.push(83);\n  camera.keysRight.push(68);\n\n  // body mesh to trigger collisions with other meshes\n  const bodyMesh = MeshBuilder.CreateBox(\"cameraBody\", {\n    height: 2,\n    width: 1,\n  });\n  // hide the body mesh\n  bodyMesh.isVisible = false;\n  // parent the body mesh to the camera\n  bodyMesh.parent = camera;\n\n  // Jump\n  scene.onKeyboardObservable.add((kbinfo) => {\n    if (kbinfo.type === 1 && kbinfo.event.code === \"Space\") {\n      if (grounded) {\n        camera.cameraDirection.y += 0.5;\n        grounded = false;\n      }\n    }\n  });\n\n  // When camera hits something\n  camera.onCollide = (collidedMesh) => {\n    console.log(collidedMesh.name);\n    grounded = true;\n    if (collidedMesh.name === \"deadzone\") {\n      camera.position = new Vector3(0, 1.5, 0);\n    }\n  };\n\n  return camera;\n};\n","import {\n  Camera,\n  CannonJSPlugin,\n  CubeTexture,\n  DefaultRenderingPipeline,\n  HemisphericLight,\n  Scene,\n  Texture,\n  Vector3,\n} from \"@babylonjs/core\";\nimport * as CANNON from \"cannon\";\n\nexport const setupEnvironment = (scene: Scene, camera: Camera) => {\n  // Set the physics engine\n  window.CANNON = CANNON;\n\n  const envTexturePath = \"assets/textures/snowy_park.env\";\n\n  const envText = CubeTexture.CreateFromPrefilteredData(envTexturePath, scene);\n\n  // // Fix orientation of the skybox texture\n  envText.coordinatesMode = Texture.SKYBOX_MODE;\n\n  // Creates default HDR environment\n  scene.createDefaultEnvironment({\n    skyboxTexture: envText,\n    skyboxSize: 200,\n    environmentTexture: envTexturePath,\n  });\n\n  // add glow layer\n  // const gl = new GlowLayer(\"glow\", scene);\n  // gl.intensity = 0.2;\n\n  // setup pipeline\n  const pipeline = new DefaultRenderingPipeline(\n    \"defaultPipeline\", // The name of the pipeline\n    false, // Do you want the pipeline to use HDR texture?\n    scene, // The scene instance\n    [camera] // The list of cameras to be attached to\n  );\n  pipeline.samples = 4;\n  pipeline.fxaaEnabled = true;\n  pipeline.sharpenEnabled = true;\n  pipeline.sharpen.edgeAmount = 0.9;\n  pipeline.bloomEnabled = true;\n  pipeline.glowLayerEnabled = true;\n\n  if (pipeline.glowLayer) {\n    pipeline.glowLayer.intensity = 0.4;\n  }\n\n  // add a little light\n  const light = new HemisphericLight(\"light\", new Vector3(0, 1, 0), scene);\n  light.intensity = 0.8;\n\n  // setup physics\n  const gravityVector = new Vector3(0, -9.81, 0);\n  scene.enablePhysics(gravityVector, new CannonJSPlugin());\n  scene.collisionsEnabled = true;\n\n  // Set gravity for objects with collisions\n  scene.gravity = new Vector3(0, -0.1, 0);\n  return pipeline;\n};\n"],"names":["importedDebugger","runDebugger","scene","debugLayer","isVisible","hide","show","console","log","createSixDegreesOfDrag","mesh","sixdof","SixDofDragBehavior","onDragStartObservable","add","physicsImpostor","sleep","onDragEndObservable","wakeUp","createSnowBall","snowMat","materials","find","mat","name","sb","MeshBuilder","diameter","PhysicsImpostor","mass","restitution","position","Vector3","material","addBehavior","onCollide","collidedMesh","dispose","enableXR","floorMeshes","pipeline","createDefaultXRExperienceAsync","xr","baseExperience","featuresManager","enableFeature","WebXRFeatureName","xrInput","input","physicsProperties","impostorSize","impostorType","enableHeadsetImpostor","pickBlockerMeshes","observers","meshesUnderPointer","tmpVec","tmpRay","Ray","lastTimestamp","oldPos","onControllerAddedObservable","inputSource","onMotionControllerInitObservable","motionController","onModelLoadedObservable","_mc","grip","handedness","xr_ids","getComponentIds","getComponent","onButtonStateChangedObservable","pressed","squeeze","getComponentOfType","changes","getWorldPointerRayToRef","direction","scaleInPlace","pointer","meshUnderPointer","pointerSelection","getMeshUnderPointer","uniqueId","Animation","clone","BezierCurveEase","sessionManager","onXRFrameObservable","delta","currentTimestamp","copyFrom","addInPlace","subtractToRef","setLinearVelocity","setAngularVelocity","setTimeout","meshes","filter","remove","onStateChangedObservable","state","WebXRState","cameras","push","camera","createScene","engine","_canvas","Scene","assetManager","AssetsManager","displayLoadingUI","assetsManager","loadingScreen","Promise","resolve","assetsContainer","models","containers","textures","images","sounds","cubeTextures","model","modelTask","addMeshTask","window","location","href","onSuccess","task","onError","err","container","containerTask","addContainerTask","cubeText","cubeTextureTask","addCubeTextureTask","undefined","sound","binaryTask","addBinaryFileTask","texture","textTask","addTextureTask","image","imageTask","addImageTask","onProgress","remainingCount","totalCount","percent","Number","toFixed","loadingUIText","progress","onFinish","_tasks","load","assets","snowScene","loadedMeshes","checkCollisions","canvas","getEngine","getRenderingCanvas","grounded","FreeCamera","attachControl","applyGravity","ellipsoid","minZ","speed","angularSensibility","keysUp","keysLeft","keysDown","keysRight","bodyMesh","height","width","parent","onKeyboardObservable","kbinfo","type","event","code","cameraDirection","y","setupCamera","rotation","Math","PI","CANNON","envTexturePath","envText","CubeTexture","coordinatesMode","Texture","createDefaultEnvironment","skyboxTexture","skyboxSize","environmentTexture","DefaultRenderingPipeline","samples","fxaaEnabled","sharpenEnabled","sharpen","edgeAmount","bloomEnabled","glowLayerEnabled","glowLayer","intensity","HemisphericLight","gravityVector","enablePhysics","CannonJSPlugin","collisionsEnabled","gravity","setupEnvironment","groundFloors","ground","subdivisions","receiveShadows","friction","disableBidirectionalTransformation","deadZone","addEventListener","ev","ctrlKey","altKey","MainScreen"],"sourceRoot":""}