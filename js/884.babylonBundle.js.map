{"version":3,"file":"js/884.babylonBundle.js","mappings":"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","sources":["webpack://webxrdemo/./src/support/debugger.ts","webpack://webxrdemo/./src/support/utils.ts","webpack://webxrdemo/./src/support/xr.ts","webpack://webxrdemo/./src/scenes/main.ts","webpack://webxrdemo/./src/support/assetManager.ts","webpack://webxrdemo/./src/support/camera.ts","webpack://webxrdemo/./src/support/environment.ts"],"sourcesContent":["import { Scene } from \"@babylonjs/core\";\n\nlet importedDebugger = false;\nexport const runDebugger = async (scene: Scene) => {\n  if (!importedDebugger) {\n    await import(\"@babylonjs/core/Debug/debugLayer\");\n    await import(\"@babylonjs/inspector\");\n    importedDebugger = true;\n  }\n  if (scene.debugLayer?.isVisible()) {\n    scene.debugLayer?.hide();\n  } else {\n    try {\n      await scene.debugLayer?.show();\n    } catch (err) {\n      console.log(err);\n    }\n  }\n};\n","import {\n  AbstractMesh,\n  MeshBuilder,\n  PhysicsImpostor,\n  Scene,\n  SixDofDragBehavior,\n  Vector3,\n} from \"@babylonjs/core\";\n\nexport const createSixDegreesOfDrag = (mesh: AbstractMesh) => {\n  const sixdof = new SixDofDragBehavior();\n  sixdof.onDragStartObservable.add(() => {\n    if (mesh.physicsImpostor) {\n      mesh.physicsImpostor.sleep();\n    }\n  });\n  sixdof.onDragEndObservable.add(() => {\n    if (mesh.physicsImpostor) {\n      mesh.physicsImpostor.wakeUp();\n    }\n  });\n  return sixdof;\n};\n\nexport const createSnowBall = (scene?: Scene) => {\n  const snowMat = scene?.materials.find((mat) => mat.name === \"Snow\");\n  const sb = MeshBuilder.CreateSphere(\"snowball\", { diameter: 0.3 });\n  sb.checkCollisions = true;\n  sb.physicsImpostor = new PhysicsImpostor(\n    sb,\n    PhysicsImpostor.SphereImpostor,\n    {\n      mass: 1,\n      restitution: 0.9,\n    },\n    scene\n  );\n  sb.position = new Vector3(0, 0.4, -4);\n  if (snowMat) {\n    sb.material = snowMat;\n  }\n  sb.addBehavior(createSixDegreesOfDrag(sb));\n};\n","import {\n  Scene,\n  WebXRFeatureName,\n  PhysicsImpostor,\n  AbstractMesh,\n  WebXRState,\n  DefaultRenderingPipeline,\n  Vector3,\n  Ray,\n  Animation,\n  BezierCurveEase,\n} from \"@babylonjs/core\";\nimport { createSnowBall } from \"./utils\";\n\nexport const enableXR = async (\n  scene: Scene,\n  floorMeshes: AbstractMesh[],\n  pipeline?: DefaultRenderingPipeline\n) => {\n  // enable xr\n  const xr = await scene.createDefaultXRExperienceAsync();\n\n  // enable physics for xr\n  xr.baseExperience.featuresManager.enableFeature(\n    WebXRFeatureName.PHYSICS_CONTROLLERS,\n    \"latest\",\n    {\n      xrInput: xr.input,\n      physicsProperties: {\n        restitution: 0.5,\n        impostorSize: 0.1,\n        impostorType: PhysicsImpostor.BoxImpostor,\n      },\n      enableHeadsetImpostor: true,\n    }\n  );\n\n  // teleportation features\n  xr.baseExperience.featuresManager.enableFeature(\n    WebXRFeatureName.TELEPORTATION,\n    \"stable\",\n    {\n      xrInput: xr.input,\n      floorMeshes,\n      pickBlockerMeshes: [],\n    }\n  );\n\n  let observers: any = {};\n  let meshesUnderPointer: any = {};\n  const tmpVec = new Vector3();\n  const tmpRay = new Ray(new Vector3(), new Vector3());\n  let lastTimestamp = 0;\n  const oldPos = new Vector3();\n\n  xr.input.onControllerAddedObservable.add((inputSource) => {\n    inputSource.onMotionControllerInitObservable.add((motionController) => {\n      motionController.onModelLoadedObservable.add(async (_mc) => {\n        const mesh = inputSource.grip;\n        if (mesh && motionController.handedness === \"left\") {\n          const xr_ids = motionController.getComponentIds();\n          // get x button\n          const xbuttonComponent = motionController.getComponent(xr_ids[3]);\n          xbuttonComponent.onButtonStateChangedObservable.add(() => {\n            if (xbuttonComponent.pressed) {\n              console.log(\"X pressed!\");\n            }\n          });\n        }\n\n        const squeeze = motionController.getComponentOfType(\"squeeze\");\n        if (squeeze) {\n          squeeze.onButtonStateChangedObservable.add(() => {\n            if (squeeze.changes.pressed) {\n              if (squeeze.pressed) {\n                inputSource.getWorldPointerRayToRef(tmpRay, true);\n                tmpRay.direction.scaleInPlace(1.5);\n                const position = inputSource.grip\n                  ? inputSource.grip.position\n                  : inputSource.pointer.position;\n                let mesh = scene.meshUnderPointer;\n                if (xr.pointerSelection.getMeshUnderPointer) {\n                  mesh = xr.pointerSelection.getMeshUnderPointer(\n                    inputSource.uniqueId\n                  );\n                }\n                if (mesh && mesh.physicsImpostor && mesh.name !== \"ground\") {\n                  Animation.CreateAndStartAnimation(\n                    \"meshmove\",\n                    mesh,\n                    \"position\",\n                    30,\n                    15,\n                    mesh.position.clone(),\n                    position.add(tmpRay.direction),\n                    Animation.ANIMATIONLOOPMODE_CONSTANT,\n                    new BezierCurveEase(0.3, -0.75, 0.7, 1.6),\n                    () => {\n                      if (!mesh) return;\n                      meshesUnderPointer[inputSource.uniqueId] = mesh;\n                      observers[inputSource.uniqueId] =\n                        xr.baseExperience.sessionManager.onXRFrameObservable.add(\n                          () => {\n                            const delta =\n                              xr.baseExperience.sessionManager\n                                .currentTimestamp - lastTimestamp;\n                            lastTimestamp =\n                              xr.baseExperience.sessionManager.currentTimestamp;\n                            inputSource.getWorldPointerRayToRef(tmpRay, true);\n                            tmpRay.direction.scaleInPlace(1.5);\n                            const position = inputSource.grip\n                              ? inputSource.grip.position\n                              : inputSource.pointer.position;\n                            tmpVec.copyFrom(position);\n                            tmpVec.addInPlace(tmpRay.direction);\n                            tmpVec.subtractToRef(oldPos, tmpVec);\n                            tmpVec.scaleInPlace(1000 / delta);\n                            meshesUnderPointer[\n                              inputSource.uniqueId\n                            ].position.copyFrom(position);\n                            meshesUnderPointer[\n                              inputSource.uniqueId\n                            ].position.addInPlace(tmpRay.direction);\n                            oldPos.copyFrom(\n                              meshesUnderPointer[inputSource.uniqueId].position\n                            );\n                            meshesUnderPointer[\n                              inputSource.uniqueId\n                            ].physicsImpostor.setLinearVelocity(Vector3.Zero());\n                            meshesUnderPointer[\n                              inputSource.uniqueId\n                            ].physicsImpostor.setAngularVelocity(\n                              Vector3.Zero()\n                            );\n                          }\n                        );\n                    }\n                  );\n                }\n              } else {\n                // throw the object\n                if (\n                  observers[inputSource.uniqueId] &&\n                  meshesUnderPointer[inputSource.uniqueId]\n                ) {\n                  setTimeout(() => {\n                    const snowballs = scene.meshes.filter(\n                      (mesh) => mesh.name === \"snowball\"\n                    );\n                    for (const snowball of snowballs) {\n                      snowball.dispose();\n                    }\n                    createSnowBall(scene);\n                  }, 2000);\n                  xr.baseExperience.sessionManager.onXRFrameObservable.remove(\n                    observers[inputSource.uniqueId]\n                  );\n                  observers[inputSource.uniqueId] = null;\n                  meshesUnderPointer[\n                    inputSource.uniqueId\n                  ].physicsImpostor.setLinearVelocity(tmpVec);\n                }\n              }\n            }\n          });\n        }\n      });\n    });\n  });\n\n  xr.baseExperience.onStateChangedObservable.add((state) => {\n    switch (state) {\n      case WebXRState.IN_XR:\n        // XR is initialized and already submitted one frame\n        if (pipeline) {\n          pipeline.cameras.push(xr.baseExperience.camera);\n        }\n      case WebXRState.ENTERING_XR:\n      // xr is being initialized, enter XR request was made\n      case WebXRState.EXITING_XR:\n      // xr exit request was made. not yet done.\n      case WebXRState.NOT_IN_XR:\n      // either out or not yet in XR\n    }\n  });\n  return xr;\n};\n","import {\n  AssetsManager,\n  Engine,\n  Scene,\n  AbstractMesh,\n  WebXRDefaultExperience,\n  Vector3,\n  PhysicsImpostor,\n  MeshBuilder,\n} from \"@babylonjs/core\";\nimport { CreateSceneClass } from \"../createScene\";\nimport { loadAllAssets } from \"../support/assetManager\";\nimport { setupCamera } from \"../support/camera\";\nimport { runDebugger } from \"../support/debugger\";\nimport { setupEnvironment } from \"../support/environment\";\nimport { createSnowBall } from \"../support/utils\";\nimport { enableXR } from \"../support/xr\";\n\nexport class MainScreen implements CreateSceneClass {\n  createScene = async (\n    engine: Engine,\n    _canvas: HTMLCanvasElement\n  ): Promise<Scene> => {\n    // Create scene\n    const scene = new Scene(engine);\n\n    // Create AssetManager\n    const assetManager = new AssetsManager(scene);\n\n    engine.displayLoadingUI();\n    // Load up all assets\n    const assets = await loadAllAssets(assetManager, engine.loadingScreen);\n\n    const snowScene = assets.models[\"snowScene.glb\"];\n    if (snowScene) {\n      for (const mesh of snowScene.loadedMeshes) {\n        mesh.checkCollisions = true;\n      }\n    }\n\n    // Setup Camera\n    const camera = setupCamera(scene);\n    camera.rotation.y = -Math.PI;\n\n    // Setup a pipeline\n    const pipeline = setupEnvironment(scene, camera);\n\n    // Get snow material\n    const snowMat = scene.materials.find((mat) => mat.name === \"Snow\");\n\n    // Setup Floor\n    const groundFloors: AbstractMesh[] = [];\n\n    const ground = MeshBuilder.CreateGround(\"ground\", {\n      width: 50,\n      height: 50,\n      subdivisions: 20,\n    });\n    ground.receiveShadows = true;\n    ground.position = new Vector3(0, 0, 0);\n    ground.checkCollisions = true;\n    ground.physicsImpostor = new PhysicsImpostor(\n      ground,\n      PhysicsImpostor.BoxImpostor,\n      {\n        mass: 0,\n        friction: 0.8,\n        restitution: 0.5,\n        disableBidirectionalTransformation: true,\n      },\n      scene\n    );\n    groundFloors.push(ground);\n    if (snowMat) {\n      ground.material = snowMat;\n    }\n\n    const deadZone = MeshBuilder.CreateGround(\"deadzone\", {\n      width: 200,\n      height: 200,\n      subdivisions: 20,\n    });\n\n    deadZone.checkCollisions = true;\n    deadZone.position = new Vector3(0, -1, 0);\n    deadZone.isVisible = false;\n\n    createSnowBall(scene);\n\n    await new Promise<null | WebXRDefaultExperience>(async (resolve) => {\n      try {\n        const xr = await enableXR(scene, groundFloors, pipeline);\n        resolve(xr);\n      } catch (err) {\n        console.log(\"not able to offer VR\");\n        resolve(null);\n      }\n    });\n\n    window.addEventListener(\"keydown\", async (ev) => {\n      // debugger Ctrl+Alt+I\n      if (ev.ctrlKey && ev.altKey && ev.code === \"KeyI\") {\n        await runDebugger(scene);\n      }\n    });\n\n    return scene;\n  };\n}\n\nexport default new MainScreen();\n","import {\n  AssetsManager,\n  BinaryFileAssetTask,\n  ContainerAssetTask,\n  CubeTextureAssetTask,\n  ILoadingScreen,\n  ImageAssetTask,\n  MeshAssetTask,\n  TextureAssetTask,\n} from \"@babylonjs/core\";\nimport { CustomLoadingScreen } from \"./customLoader\";\n\nexport interface AssetsObject {\n  containers: {\n    [key: string]: ContainerAssetTask;\n  };\n  models: {\n    [key: string]: MeshAssetTask;\n  };\n  sounds: {\n    [key: string]: BinaryFileAssetTask;\n  };\n  textures: { [key: string]: TextureAssetTask };\n  images: { [key: string]: ImageAssetTask };\n  cubeTextures: { [key: string]: CubeTextureAssetTask };\n}\n\nexport const loadAllAssets = (\n  assetsManager: AssetsManager,\n  loadingScreen?: ILoadingScreen | CustomLoadingScreen\n): Promise<AssetsObject> =>\n  new Promise((resolve) => {\n    let cubeTextures: string[] = [];\n    let images: string[] = [];\n    let textures: string[] = [];\n    let sounds: string[] = [];\n    let containerModels: string[] = [];\n    let models: string[] = [\"snowScene.glb\"];\n\n    const assetsContainer: AssetsObject = {\n      models: {},\n      containers: {},\n      textures: {},\n      images: {},\n      sounds: {},\n      cubeTextures: {},\n    };\n\n    for (const model of models) {\n      const modelTask = assetsManager.addMeshTask(\n        model,\n        \"\",\n        `${window.location.href}assets/models/`,\n        model\n      );\n      modelTask.onSuccess = (task) => {\n        assetsContainer.models[model] = task;\n      };\n\n      modelTask.onError = (err) => {\n        console.log(\"model load err: \", err);\n      };\n    }\n\n    for (const container of containerModels) {\n      const containerTask = assetsManager.addContainerTask(\n        container,\n        \"\",\n        `${window.location.href}assets/models/`,\n        container\n      );\n      containerTask.onSuccess = (task) => {\n        assetsContainer.containers[container] = task;\n      };\n\n      containerTask.onError = (err) => {\n        console.log(\"container model load err: \", err);\n      };\n    }\n\n    for (const cubeText of cubeTextures) {\n      const cubeTextureTask = assetsManager.addCubeTextureTask(\n        cubeText,\n        `${window.location.href}assets/textures/${cubeText}`,\n        undefined,\n        undefined,\n        undefined,\n        true\n      );\n      cubeTextureTask.onSuccess = (task) => {\n        assetsContainer.cubeTextures[cubeText] = task;\n      };\n\n      cubeTextureTask.onError = (err) => {\n        console.log(\"cube texture load err: \", err);\n      };\n    }\n\n    for (const sound of sounds) {\n      const binaryTask = assetsManager.addBinaryFileTask(\n        sound,\n        `${window.location.href}assets/sounds/${sound}`\n      );\n      binaryTask.onSuccess = (task) => {\n        assetsContainer.sounds[sound] = task;\n      };\n\n      binaryTask.onError = (err) => {\n        console.log(\"sound load err: \", err);\n      };\n    }\n\n    for (const texture of textures) {\n      const textTask = assetsManager.addTextureTask(\n        texture,\n        `${window.location.href}assets/textures/${texture}`,\n        false,\n        false\n      );\n      textTask.onSuccess = (task) => {\n        assetsContainer.textures[texture] = task;\n      };\n\n      textTask.onError = (err) => {\n        console.log(\"texture load err: \", err);\n      };\n    }\n\n    for (const image of images) {\n      const imageTask = assetsManager.addImageTask(\n        image,\n        `${window.location.href}assets/images/${image}`\n      );\n      imageTask.onSuccess = (task) => {\n        assetsContainer.images[image] = task;\n      };\n\n      imageTask.onError = (err) => {\n        console.log(\"texture load err: \", err);\n      };\n    }\n\n    assetsManager.onProgress = (remainingCount, totalCount) => {\n      if (!loadingScreen) {\n        return;\n      }\n      const loaded = totalCount - remainingCount;\n      const percent = Number((loaded / totalCount) * 100).toFixed(0);\n      loadingScreen.loadingUIText = `${\n        totalCount - remainingCount\n      } of ${totalCount} loaded`;\n      if (loadingScreen instanceof CustomLoadingScreen) {\n        loadingScreen.progress = `${percent}%`;\n      }\n    };\n    assetsManager.onFinish = (_tasks) => {\n      resolve(assetsContainer);\n    };\n    assetsManager.load();\n  });\n","import { FreeCamera, MeshBuilder, Scene, Vector3 } from \"@babylonjs/core\";\n\nexport const setupCamera = (scene: Scene) => {\n  // This creates the canvas\n  const canvas = scene.getEngine().getRenderingCanvas();\n\n  // Check if camera/player grounded\n  let grounded = false;\n\n  // This creates the camera\n  const camera = new FreeCamera(\"camera\", new Vector3(0, 1.5, 0), scene);\n\n  // This attaches the camera to the canvas\n  camera.attachControl(canvas, true);\n  // Set camera for first person controller\n  camera.applyGravity = true;\n  // Allow checking for collisions\n  camera.checkCollisions = true;\n  // Ellipsoid to provide camera a \"body\"\n  camera.ellipsoid = new Vector3(0.2, 0.8, 0.2);\n  // Camera clipping\n  camera.minZ = 0.01;\n  // Camera \"walking\" speed\n  camera.speed = 0.3;\n  // Reduce sensitivity on movement\n  camera.angularSensibility = 5000;\n\n  // Movement WSAD\n  camera.keysUp.push(87);\n  camera.keysLeft.push(65);\n  camera.keysDown.push(83);\n  camera.keysRight.push(68);\n\n  // body mesh to trigger collisions with other meshes\n  const bodyMesh = MeshBuilder.CreateBox(\"cameraBody\", {\n    height: 2,\n    width: 1,\n  });\n  // hide the body mesh\n  bodyMesh.isVisible = false;\n  // parent the body mesh to the camera\n  bodyMesh.parent = camera;\n\n  // Jump\n  scene.onKeyboardObservable.add((kbinfo) => {\n    if (kbinfo.type === 1 && kbinfo.event.code === \"Space\") {\n      if (grounded) {\n        camera.cameraDirection.y += 0.5;\n        grounded = false;\n      }\n    }\n  });\n\n  // When camera hits something\n  camera.onCollide = (collidedMesh) => {\n    grounded = true;\n    if (collidedMesh.name === \"deadzone\") {\n      camera.position = new Vector3(0, 1.5, 0);\n    }\n  };\n\n  return camera;\n};\n","import {\n  Camera,\n  CannonJSPlugin,\n  CubeTexture,\n  DefaultRenderingPipeline,\n  HemisphericLight,\n  Scene,\n  Texture,\n  Vector3,\n} from \"@babylonjs/core\";\nimport * as CANNON from \"cannon\";\n\nexport const setupEnvironment = (scene: Scene, camera: Camera) => {\n  // Set the physics engine\n  window.CANNON = CANNON;\n\n  const envTexturePath = \"assets/textures/snowy_park.env\";\n\n  const envText = CubeTexture.CreateFromPrefilteredData(envTexturePath, scene);\n\n  // // Fix orientation of the skybox texture\n  envText.coordinatesMode = Texture.SKYBOX_MODE;\n\n  // Creates default HDR environment\n  scene.createDefaultEnvironment({\n    skyboxTexture: envText,\n    skyboxSize: 200,\n    environmentTexture: envTexturePath,\n  });\n\n  // add glow layer\n  // const gl = new GlowLayer(\"glow\", scene);\n  // gl.intensity = 0.2;\n\n  // setup pipeline\n  const pipeline = new DefaultRenderingPipeline(\n    \"defaultPipeline\", // The name of the pipeline\n    false, // Do you want the pipeline to use HDR texture?\n    scene, // The scene instance\n    [camera] // The list of cameras to be attached to\n  );\n  pipeline.samples = 4;\n  pipeline.fxaaEnabled = true;\n  pipeline.sharpenEnabled = true;\n  pipeline.sharpen.edgeAmount = 0.9;\n  pipeline.bloomEnabled = true;\n  pipeline.glowLayerEnabled = true;\n\n  if (pipeline.glowLayer) {\n    pipeline.glowLayer.intensity = 0.4;\n  }\n\n  // add a little light\n  const light = new HemisphericLight(\"light\", new Vector3(0, 1, 0), scene);\n  light.intensity = 0.8;\n\n  // setup physics\n  const gravityVector = new Vector3(0, -9.81, 0);\n  scene.enablePhysics(gravityVector, new CannonJSPlugin());\n  scene.collisionsEnabled = true;\n\n  // Set gravity for objects with collisions\n  scene.gravity = new Vector3(0, -0.1, 0);\n  return pipeline;\n};\n"],"names":["importedDebugger","runDebugger","scene","debugLayer","isVisible","hide","show","console","log","createSnowBall","mesh","sixdof","snowMat","materials","find","mat","name","sb","MeshBuilder","diameter","checkCollisions","physicsImpostor","PhysicsImpostor","mass","restitution","position","Vector3","material","addBehavior","SixDofDragBehavior","onDragStartObservable","add","sleep","onDragEndObservable","wakeUp","enableXR","floorMeshes","pipeline","createDefaultXRExperienceAsync","xr","baseExperience","featuresManager","enableFeature","WebXRFeatureName","xrInput","input","physicsProperties","impostorSize","impostorType","enableHeadsetImpostor","pickBlockerMeshes","observers","meshesUnderPointer","tmpVec","tmpRay","Ray","lastTimestamp","oldPos","onControllerAddedObservable","inputSource","onMotionControllerInitObservable","motionController","onModelLoadedObservable","_mc","grip","handedness","xr_ids","getComponentIds","getComponent","onButtonStateChangedObservable","pressed","squeeze","getComponentOfType","changes","getWorldPointerRayToRef","direction","scaleInPlace","pointer","meshUnderPointer","pointerSelection","getMeshUnderPointer","uniqueId","Animation","clone","BezierCurveEase","sessionManager","onXRFrameObservable","delta","currentTimestamp","copyFrom","addInPlace","subtractToRef","setLinearVelocity","setAngularVelocity","setTimeout","meshes","filter","dispose","remove","onStateChangedObservable","state","WebXRState","cameras","push","camera","createScene","engine","_canvas","Scene","assetManager","AssetsManager","displayLoadingUI","assetsManager","loadingScreen","Promise","resolve","assetsContainer","models","containers","textures","images","sounds","cubeTextures","model","modelTask","addMeshTask","window","location","href","onSuccess","task","onError","err","container","containerTask","addContainerTask","cubeText","cubeTextureTask","addCubeTextureTask","undefined","sound","binaryTask","addBinaryFileTask","texture","textTask","addTextureTask","image","imageTask","addImageTask","onProgress","remainingCount","totalCount","percent","Number","toFixed","loadingUIText","progress","onFinish","_tasks","load","assets","snowScene","loadedMeshes","canvas","getEngine","getRenderingCanvas","grounded","FreeCamera","attachControl","applyGravity","ellipsoid","minZ","speed","angularSensibility","keysUp","keysLeft","keysDown","keysRight","bodyMesh","height","width","parent","onKeyboardObservable","kbinfo","type","event","code","cameraDirection","y","onCollide","collidedMesh","setupCamera","rotation","Math","PI","CANNON","envTexturePath","envText","CubeTexture","coordinatesMode","Texture","createDefaultEnvironment","skyboxTexture","skyboxSize","environmentTexture","DefaultRenderingPipeline","samples","fxaaEnabled","sharpenEnabled","sharpen","edgeAmount","bloomEnabled","glowLayerEnabled","glowLayer","intensity","HemisphericLight","gravityVector","enablePhysics","CannonJSPlugin","collisionsEnabled","gravity","setupEnvironment","groundFloors","ground","subdivisions","receiveShadows","friction","disableBidirectionalTransformation","deadZone","addEventListener","ev","ctrlKey","altKey","MainScreen"],"sourceRoot":""}